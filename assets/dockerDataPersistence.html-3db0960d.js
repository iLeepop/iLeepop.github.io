import{_ as n,o as a,c as s,a as e}from"./app-5539d687.js";const t={},i=e(`<h1 id="数据持久化" tabindex="-1"><a class="header-anchor" href="#数据持久化" aria-hidden="true">#</a> 数据持久化</h1><p><strong>Docker 提供了三种实时同步（宿主机与容器 FS 间数据的同步）方式：</strong></p><ul><li>数据卷</li><li>Bind mounts（绑定挂载）</li><li>tmpfs（临时文件系统）</li></ul><h2 id="镜像持久化" tabindex="-1"><a class="header-anchor" href="#镜像持久化" aria-hidden="true">#</a> 镜像持久化</h2><p>理解定制镜像持久化方式针对的应用场景：对 UnionFS 产生一次性变化，且这种变化易 于持久化为镜像。不适合变更非常频繁的实时性场景。</p><h3 id="需求" tabindex="-1"><a class="header-anchor" href="#需求" aria-hidden="true">#</a> 需求</h3><p>为 tomcat:10.0 镜像修改其 webapps 目录。原本该目录内容 是空的，用户访问 tomcat 页面会报 404，而真正的内容是在 webapps.dist 中。现要将原 webapps 目录删除，然后重命名 webapps.dist 目录为 webapps，以使用户可以看到 tomcat 页面。</p><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h3><h4 id="以分离模式启动-tomcat-容器" tabindex="-1"><a class="header-anchor" href="#以分离模式启动-tomcat-容器" aria-hidden="true">#</a> 以分离模式启动 tomcat 容器</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mytom <span class="token parameter variable">-dp</span> <span class="token number">8081</span>:8080 tomcat:10.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时通过浏览器是无法访问到 tomcat 页面的。</p><h4 id="进入容器删除目录" tabindex="-1"><a class="header-anchor" href="#进入容器删除目录" aria-hidden="true">#</a> 进入容器删除目录</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mytom /bin/bash
//tomcat
<span class="token function">ls</span> <span class="token parameter variable">-l</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>webapps
<span class="token punctuation">..</span><span class="token punctuation">..</span>webapps.dist
//删除 webapps 目录，然后将 webapps.dist 目录重命名为 webapps。
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> webapps
<span class="token function">mv</span> webapps.dist webapps
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="通过容器生成镜像" tabindex="-1"><a class="header-anchor" href="#通过容器生成镜像" aria-hidden="true">#</a> 通过容器生成镜像</h4><p>执行 docker commit 命令，以当前运行的容器为范本生成镜像。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">&quot;modify webapps&quot;</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">&quot;Jerry&quot;</span> mytom tomcat10:own
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-a 指定该镜像的作者</li><li>tomcat10:own 为新镜像的 repository:tag</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> images
---
REPOSITORY TAG <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
tomcat10 own
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="测试新镜像" tabindex="-1"><a class="header-anchor" href="#测试新镜像" aria-hidden="true">#</a> 测试新镜像</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> myowntom <span class="token parameter variable">-dp</span> <span class="token number">8081</span>:8080 tomcat10:own
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以访问🉑</p><h2 id="数据卷" tabindex="-1"><a class="header-anchor" href="#数据卷" aria-hidden="true">#</a> 数据卷</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>数据卷是宿主机中的一个特殊的文件/目录，这个文件/目录与容器中的另一个文件/目 录进行了直接关联，在任何一端对文件/目录的写操作，在另一端都会同时发生相应变化。 在宿主中的这个文件/目录就称为数据卷，而容器中的这个关联文件/目录则称为该数据卷在 该容器中的挂载点。</p><p>数据卷的设计目的就是为了实现数据持久化，其完全独立于容器的生命周期，属于宿主 机文件系统，但不属于 UnionFS。因此，容器被删除时，不会删除其挂载的数据卷。</p><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h3><p><strong>数据卷具有如下明显特性：</strong></p><ul><li>数据卷在容器启动时初始化，如果容器启动后容器本身已经包含了数据，那么，这些数 据会在容器启动后直接出现在数据卷中，反之亦然</li><li>可以对数据卷或挂载点中的内容直接修改，修改后对方立即可看到</li><li>数据卷会一直存在，即使挂载数据卷的容器已经被删除</li><li>数据卷可以在容器之间共享和重用</li></ul><h2 id="创建数据卷" tabindex="-1"><a class="header-anchor" href="#创建数据卷" aria-hidden="true">#</a> 创建数据卷</h2><h3 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h3><p><strong>数据卷是在使用 docker run 启动容器时指定的，其语法格式为：</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run –it –v /宿主机目录绝对路径:/容器内目录绝对路径 镜像
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**注：**无论是宿主机中的数据卷还是容器中的挂载点，如果指定的目录不存在，那么 docker 引擎都会自动创建。即使是多级目录不存在。</p><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h3><p>在宿主机中的/root/host_mount 目录与 ubuntu 容器的/opt/uc_mount 目录间建立关联， 即宿主机中的/root/host_mount 目录作为数据卷，而 ubuntu 容器的/opt/uc_mount 目录作为 挂载点。</p><p>以交互方式启动一个 ubuntu 容器，同时指定在启动容器时创建数据卷。容器启动完毕 后在容器中查看/opt 目录，可以看到新建了一个 uc_mount 子目录。这个就是容器中的挂载 点目录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> myubuntu <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /root/host_mount:/opt/uc_mount ubuntu:latest /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再打开一个会话窗口，查看/root 目录，可以看到新建了一个 host_mount 目录。这个就数据卷目录。</p><h3 id="数据卷-挂载点互操作" tabindex="-1"><a class="header-anchor" href="#数据卷-挂载点互操作" aria-hidden="true">#</a> 数据卷/挂载点互操作</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#宿主机</span>
host_mount<span class="token punctuation">]</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;Hi&quot;</span> <span class="token operator">&gt;</span> hello.txt

<span class="token comment">#myubuntu</span>
uc_mount<span class="token punctuation">]</span> ll
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.hello.txt
uc_mount<span class="token punctuation">]</span> <span class="token function">cat</span> hello.txt
<span class="token operator">&gt;&gt;</span>Hi
uc_mount<span class="token punctuation">]</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;World&quot;</span> <span class="token operator">&gt;</span> hello.txt

<span class="token comment">#宿主机</span>
host_mount<span class="token punctuation">]</span> ll
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.hello.txt
host_mount<span class="token punctuation">]</span> <span class="token function">cat</span> hello.txt
<span class="token operator">&gt;&gt;</span>Hi
<span class="token operator">&gt;&gt;</span>World
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="停止操作" tabindex="-1"><a class="header-anchor" href="#停止操作" aria-hidden="true">#</a> 停止操作</h3><p>即使容器停止了，在宿主机中只要修改了数据卷目录内容，在重新启动容器后，该修改 过的数据仍会出现在容器中。因为容器是一个 UnionFS，是一个存在于宿主机中的文件系统， 无论容器是否运行，该 FS 都是存在的。</p><p>通过 exit 退出并停止容器。</p><h3 id="查看数据卷详情" tabindex="-1"><a class="header-anchor" href="#查看数据卷详情" aria-hidden="true">#</a> 查看数据卷详情</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> inspect myubuntu
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token string">&quot;Mounts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
	<span class="token punctuation">{</span>
		<span class="token string">&quot;Type&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;bind&quot;</span>,
		<span class="token string">&quot;source&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/root/host_mount&quot;</span>,
		<span class="token string">&quot;Destination&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/opt/uc_mount&quot;</span>,
		<span class="token string">&quot;Mode&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>,
		<span class="token string">&quot;RW&quot;</span><span class="token builtin class-name">:</span> true,
		<span class="token string">&quot;Propagation&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;rprivate&quot;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里给出了数据卷 Source 与挂载点 Destination 的绑定关系，且容器对挂载点的<strong>默认操作权限是 RW 读写</strong>的。</p><h3 id="设置只读" tabindex="-1"><a class="header-anchor" href="#设置只读" aria-hidden="true">#</a> 设置只读</h3><p>只读数据卷，指的是容器对挂载点的操作权限是只读的。宿主机对数据卷的操作权限始 终是读写的。</p><p>有些情况下，为了防止容器在运行过程中对文件产生修改，就需要创建只读数据卷。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run –it –v /宿主机目录绝对路径:/容器内目录绝对路径:ro 镜像

<span class="token function">docker</span> inspect 容器名称
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token string">&quot;Mounts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
	<span class="token punctuation">{</span>
		<span class="token string">&quot;Type&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;...&quot;</span>,
		<span class="token string">&quot;source&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;...&quot;</span>,
		<span class="token string">&quot;Destination&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;...&quot;</span>,
		<span class="token string">&quot;Mode&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>,
		<span class="token string">&quot;RW&quot;</span><span class="token builtin class-name">:</span> false,
		<span class="token string">&quot;Propagation&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;...&quot;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>可见 RW 为 false</strong>。</p><h2 id="数据卷共享" tabindex="-1"><a class="header-anchor" href="#数据卷共享" aria-hidden="true">#</a> 数据卷共享</h2><p>当一个容器与另一个容器使用相同的数据卷时，就称这两个容器实现了“数据卷共享”。</p><h3 id="数据卷容器" tabindex="-1"><a class="header-anchor" href="#数据卷容器" aria-hidden="true">#</a> 数据卷容器</h3><p>数据卷容器是实现数据卷共享的一种非常有效的方案。 当一个容器 C 启动运行时创建并挂载了数据卷，若其它容器也需要共享该容器 C 挂载的 数据卷，这些容器只需在 docker run 启动时通过--volumes-from[容器 C] 选项即可实现数据卷 共享。此时容器 C 就称为数据卷容器。</p><h3 id="前提" tabindex="-1"><a class="header-anchor" href="#前提" aria-hidden="true">#</a> 前提</h3><p><strong>容器 1</strong>要共享前面的<strong>容器 2</strong>的数据卷，即宿主机中/root/host_mount 为数据卷目录，而这两个容器的挂载点目录都是/opt/uc_mount。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#mycent-&gt;宿主机</span>
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> mycent <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /root/host_mount:/opt/uc_mount centos:latest
<span class="token comment">#myubuntu-&gt;mycent 实现共享</span>
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> myubuntu <span class="token parameter variable">-it</span> --volumes-from mycent ubuntu:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="效果" tabindex="-1"><a class="header-anchor" href="#效果" aria-hidden="true">#</a> 效果</h3><p>经过上述操作，myubuntu 与 myubuntu2 这两个容器实现了数据卷共享。此时，无论是 在宿主机，还是 myubuntu 或 myubuntu2 任意容器中挂载点目录中的任意写操作，在另外两 方均可同步看到该写操作的结果。</p><h2 id="dockerfile-持久化" tabindex="-1"><a class="header-anchor" href="#dockerfile-持久化" aria-hidden="true">#</a> Dockerfile 持久化</h2><p>Dockerfile 持久化，其实就是通过使用 Dockerfile 的 VOLUME 指令指定数据卷方式实现的持久化。</p><h3 id="volume-指令" tabindex="-1"><a class="header-anchor" href="#volume-指令" aria-hidden="true">#</a> VOLUME 指令</h3><p>VOLUME 指令可以在容器中创建可以挂载数据卷的挂载点。其参数可以是字符串数组， 也可以是使用空格隔开的多个纯字符串。例如，VOLUME [&quot;/var/www&quot;, &quot;/etc/apache&quot;] 或 VOLUME /var/www /etc/apache。</p><h3 id="实现-1" tabindex="-1"><a class="header-anchor" href="#实现-1" aria-hidden="true">#</a> 实现</h3><h4 id="创建-1" tabindex="-1"><a class="header-anchor" href="#创建-1" aria-hidden="true">#</a> 创建</h4><p>在/root 目录中 mkdir 一个目录，例如 vols，然后在其中新建 Dockerfile，内容如下。这 里指定/opt/xxx 与/opt/ooo 为容器端的挂载点。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> centos:7</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /opt/xxx /opt/ooo</span>
<span class="token instruction"><span class="token keyword">CMD</span> /bin/bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="构建" tabindex="-1"><a class="header-anchor" href="#构建" aria-hidden="true">#</a> 构建</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-t</span> volscon <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="运行" tabindex="-1"><a class="header-anchor" href="#运行" aria-hidden="true">#</a> 运行</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> myvlos <span class="token parameter variable">-it</span> volscon
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="查看数据卷-source" tabindex="-1"><a class="header-anchor" href="#查看数据卷-source" aria-hidden="true">#</a> 查看数据卷 Source</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> inspect myvlos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,74),o=[i];function c(l,p){return a(),s("div",null,o)}const u=n(t,[["render",c],["__file","dockerDataPersistence.html.vue"]]);export{u as default};
