import{_ as p,r as o,o as e,c,b as n,d as s,e as l,a}from"./app-5539d687.js";const i={},u=a('<h1 id="network" tabindex="-1"><a class="header-anchor" href="#network" aria-hidden="true">#</a> Network</h1><p>随便记记</p><h2 id="osi-7层模型" tabindex="-1"><a class="header-anchor" href="#osi-7层模型" aria-hidden="true">#</a> OSI 7层模型</h2><h3 id="_1-物理层" tabindex="-1"><a class="header-anchor" href="#_1-物理层" aria-hidden="true">#</a> 1. 物理层</h3><p>md，世间万物的究极交互方式就是物理，没有物理就没有一切，懂？</p>',5),r=n("li",null,"光缆，一般都是光缆牵入网口",-1),d=n("li",null,"无线网口",-1),k={href:"https://www.submarinecablemap.com/",target:"_blank",rel:"noopener noreferrer"},m=a(`<p>把所有的连网设备都称为节点，节点之间通过物理层进行通信，节点可以是</p><ul><li>终端设备，比如你的电脑，或者服务器主机等等</li><li>中间设备，路由器，交换机啥的</li><li>当然不止这么点</li></ul><p>第一层的数据单元是<code>bit</code>比特，为二进制，单个<code>byte</code>字节由八个<code>bit</code>组成。</p><p>每个节点可以发送或者接收比特，以前很多设备都只能发送或只能接收，像这种就叫做<strong>单工模式</strong>，永远只有一个人在工作，累死了。</p><p>不过现在大部分都支持<strong>双工模式</strong>，也就是两边一起干活，又可以接收又可以发送，两全其美。</p><p><em><strong>网线也是，双绞线，有两种模式，A类和B类，如果网线两端都是同一个类型，那么就是单通网线，反之则是交叉网线，不过现在大部分设备都支持线序识别，所以在一般情况下其实不在乎网线是什么类型的，反正都支持双工模式</strong></em></p><p><strong>一般故障</strong></p><ul><li>网线寄了</li><li>插槽损坏，包括电路寄了</li><li>你没插好罢，会不会插啊</li></ul><h3 id="_2-数据链路层" tabindex="-1"><a class="header-anchor" href="#_2-数据链路层" aria-hidden="true">#</a> 2. 数据链路层</h3><p>这个也厉害，定义了很多规则，比如：</p><ul><li>数据的传输格式</li><li>节点之间传输的数据大小（流量控制）</li><li>数据传输可以持续的时间（路线规划）</li><li>在数据流中的错误反馈处理措施（错误控制-检测和校正）</li></ul><p>它同时具有两个子层：</p><ul><li>介质访问控制层：<code>MAC, Media Access Control</code>子层负责分配 <code>mac</code> 地址也就是硬件标识号，在每个设备制造时就已经分配好了，所有的网络行为都会对 <code>mac</code> 进行跟踪，确保网络访问正确，就像人的指纹</li><li>逻辑链路控制：<code>LLC</code> 子层处理本层的数据单元的寻址以及流量控制</li></ul><p>本层的数据单元是<strong>帧</strong><code>frame</code></p><p>每一帧包含：</p><ul><li>帧头，包含源节点与目的节点的<code>mac</code>地址</li><li>主体，由传输的<code>bit</code>组成</li><li>帧尾，包括错误检测信息，检测到错误信息可能会根据配置或协议将当前错误帧丢弃，错误或被报告给上层用于校正</li></ul><p>帧的大小通常会有一个最大值，<code>MTU, Maximum Transmission Unit</code>，巨型帧的大小超过了标准的<code>MTU</code>。</p><p><strong>一般故障</strong></p><ul><li>节点会话建立失败</li><li>会话间歇性失败</li><li>帧冲突</li></ul><h3 id="_3-网络层" tabindex="-1"><a class="header-anchor" href="#_3-网络层" aria-hidden="true">#</a> 3. 网络层</h3><p>网络层可以借助路由器的力量，帮助我们设备访问其它网络中的设备，不在仅限与节点之间的通信了。</p><p><em><strong>路由器简单点来说就是管理存放了一系列 mac 地址以及路由信息的路由表的工具，他会根据我们访问的 ip 去找到相应的 mac 地址，也就是找到对应的节点，完成访问</strong></em></p><p>这一次的数据单元变成了<strong>数据包</strong><code>data packet</code>，这个应该就没有那么陌生了，它封装了第二层的数据单元<strong>帧</strong>并且加上了<code>IP</code>地址信息，这部分被封装的数据也被称之为<strong>负载</strong><code>payload</code>。</p><p>节点连上网，西边出太阳，此时的节点会被赋予一个协议，名为<code>IP, Internet Protocol</code>，它负责管理节点的<code>IP</code>地址，它会被路由器所使用。</p><p><code>IP</code>地址通过协议<code>ARP, Address Resolution Protocol</code>与<code>mac</code>地址关联，<code>ARP</code>使用节点对应的<code>IP</code>地址解析<code>mac</code>地址。</p><p><strong>一般故障</strong></p><ul><li>路由器寄了</li><li><code>IP</code>没有正确分配或配置</li><li>可以使用命令排错 <ul><li><code>ipconfig</code>、<code>ifconfig</code></li><li><code>ping</code></li><li><code>trace</code></li></ul></li></ul><h3 id="_4-传输层" tabindex="-1"><a class="header-anchor" href="#_4-传输层" aria-hidden="true">#</a> 4. 传输层</h3><p>本层负责<strong>数据包</strong>的分段，也就是从<strong>数据包</strong>的整体角度上将其拆分成小片发送至网络。</p><ul><li><code>TCP</code>将本层的数据单元称为数据包</li><li><code>UDP</code>将本层的数据单元称为数据报<code>datagram</code></li></ul><p>鼎鼎有名的两大传输控制协议：</p><ul><li><code>TCP, Transmission Control Protocol</code>： <ul><li>面向连接</li><li>优先保证数据的完整性质量</li><li>显式的确认机制，与目的节点建立连接，发送数据时要求源节点与目的节点之间必须进行握手操作，确保数据完整、准确，正确到达</li><li>如果数据丢失，要求进行重传</li><li>确保数据包的顺序正确</li></ul></li><li><code>UDP, User Datagram Protocol</code>： <ul><li>无连接协议</li><li>优先速度</li><li>无需握手</li><li>无需等待确认，所以传输更快</li><li>但数据包容易丢失并且我们无法得知丢失了什么（狗屎）</li><li>一旦数据包被拆分，如果不给予序列号，<code>UDP</code>无法确保数据包的顺序正确</li></ul></li></ul><p>不论<code>TCP</code>还是<code>UDP</code>，都是从一个设备的端口将数据发送至另一台设备的特定端口，这些设备也必须拥有<code>IP</code>地址，而这些<code>IP</code>地址与端口号的组合被称为<strong>套接字</strong><code>socket</code>。</p><p><strong>一般故障</strong></p><ul><li>端口被禁了，看看你那该死的防火墙吧</li><li>还有可能是你路由器的原因，看看你那该死的路由器吧</li></ul><h3 id="_5-会话层" tabindex="-1"><a class="header-anchor" href="#_5-会话层" aria-hidden="true">#</a> 5. 会话层</h3><p>负责建立，维持和终止会话。</p><p>会话建立于两个网络应用之间：</p><ul><li>客户端：请求信息的应用</li><li>服务端：提供信息的应用</li><li>请求与响应：双方不断的请求以及响应信息</li></ul><p>会话根据不同场景，持续的时间可以非常短也可以非常长，过长的话有可能会导致失败。不过会话会根据采用的协议，启动各种故障解决程序，并根据所使用的应用程序，协议或者硬件，来决定会话的工作模式，<strong>单工模式</strong>，<strong>半双工模式</strong>，<strong>全双工模式</strong>。</p><p><strong>一般故障</strong></p><ul><li>服务寄了</li><li>服务器配置错误</li><li>会话错误，断连、超时等等</li></ul><h3 id="_6-表示层" tabindex="-1"><a class="header-anchor" href="#_6-表示层" aria-hidden="true">#</a> 6. 表示层</h3><p>负责传输的数据的格式。字符的编解码与转换，以及数据的加密，本层确保第七层的应用可以成功消费数据并展示数据。</p><p>三种常见的数据格式化方法：</p><ul><li><code>ASCII, American Standard Code for Information Interchange</code>：七位编码技术，是字符编码中使用最广泛的标准</li><li><code>EBDCIC, Extended Binary Coded Decimal Interchange Code</code>：补充二进制编码的十进制编码，用于大型机，<code>IBM</code>设计</li><li><code>Unicode</code>: 国际字符编码，用于全球，几乎容纳所有已知的字母，使用最平凡的</li></ul><p><em><strong>加密功能：<code>SSL</code>以及<code>TLS</code>加密协议就位于这第六层，它们为网络节点提供身份认证以及数据加密功能</strong></em></p><p><strong>一般故障</strong></p><ul><li>哥们驱动坏了吧</li></ul><h3 id="_7-应用层" tabindex="-1"><a class="header-anchor" href="#_7-应用层" aria-hidden="true">#</a> 7. 应用层</h3><p>一般开发都会接触的一层，这一层最终负责支持用户程序使用的服务，包括浏览器，QQ， Word文档。只要在后台专门执行了网络功能，那就是属于应用层的服务。</p><p>各种协议：</p><ul><li><code>FTP, File Transfer Protocol</code>：文件传输协议，用于传输文件。</li><li><code>HTTP, Hypertext Transfer Protocol</code>：超文本传输协议，用于传输网页。</li><li><code>SSH, Secure Shell</code>：安全外壳协议，用于远程登录服务器。</li><li><code>SMTP, Simple Mail Transfer Protocol</code>：简单邮件传输协议，用于发送邮件。</li><li><code>DNS, Domain Name System</code>：域名系统，用于解析域名。</li></ul><p><strong>一般故障</strong></p><ul><li>应用配置有问题</li><li>应用有问题</li><li>瞎几把一顿操作坏了</li></ul><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><p>体验一下<code>TCP</code>，接下来我们使用<code>Rust</code>搭建两个服务，一个用于接收数据，一个用于发送数据。</p><h3 id="搭建服务" tabindex="-1"><a class="header-anchor" href="#搭建服务" aria-hidden="true">#</a> 搭建服务</h3><p><strong>发送端</strong></p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token namespace">io<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Read</span><span class="token punctuation">,</span> <span class="token class-name">Write</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token namespace">net<span class="token punctuation">::</span></span><span class="token class-name">TcpStream</span><span class="token punctuation">,</span> <span class="token namespace">thread<span class="token punctuation">::</span></span>sleep<span class="token punctuation">,</span> <span class="token namespace">time<span class="token punctuation">::</span></span><span class="token class-name">Duration</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">loop</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> stream <span class="token operator">=</span> <span class="token class-name">TcpStream</span><span class="token punctuation">::</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1:8080&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;connect failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;what is your name?&quot;</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> buf <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buf<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Receiver::{}&quot;</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from_utf8_lossy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码实现了一个不断循环发送和接收消息的TCP客户端。并且设置了一个5秒的休眠时间，模拟网络延迟。</p><p><strong>接收端</strong></p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token namespace">io<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">Read</span><span class="token punctuation">,</span> <span class="token class-name">Write</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token namespace">net<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token class-name">TcpListener</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> listener <span class="token operator">=</span> <span class="token class-name">TcpListener</span><span class="token punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1:8080&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">&quot;bind failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> stream <span class="token keyword">in</span> listener<span class="token punctuation">.</span><span class="token function">incoming</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">match</span> stream <span class="token punctuation">{</span>
            <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token keyword">mut</span> stream<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">let</span> <span class="token keyword">mut</span> buf <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buf<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Sender::{}&quot;</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from_utf8_lossy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;My name is ilee&quot;</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;error: {}&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码实现了一个<code>TCP</code>服务器，监听端口 <code>8080</code>，接收客户端连接，并接收客户端发送的数据，然后打印出来，并将字符串 <strong>&quot;My name is ilee&quot;</strong> 发送给客户端。</p><p>自己试一试运行看看结果吧</p><h3 id="理解" tabindex="-1"><a class="header-anchor" href="#理解" aria-hidden="true">#</a> 理解</h3><p>对于读取到的数据，本身还是非常简单，并没有发送所谓的大数据。当面临大数据传输时，我们应该怎么处理？反观各种协议，我们应该怎么去读取不同的协议？就用最简单的<code>HTTP</code>协议来说，接收的数据当中第一条应该为<code>GET / HTTP/1.1\\r\\n</code>，我们可以根据这个来判断是HTTP协议还是其他协议。</p><p>封装其它协议也不过就是读取数据，然后根据协议规定进行解析，最后使用解析后的数据。</p>`,68);function h(g,f){const t=o("ExternalLinkIcon");return e(),c("div",null,[u,n("ul",null,[r,d,n("li",null,[s("深海通信电缆，北大西洋和北太平洋都是线:"),n("a",k,[s("参考数据"),l(t)])])]),m])}const b=p(i,[["render",h],["__file","network.html.vue"]]);export{b as default};
